- Done
  - Check events only for interested widgets (use focus for keyboard and region for mouse)
  - Add handling of disabled widget nodes
  - Add handling of custom external actions for widgets
  - Do something with return of custom handlers (the exact same thing we do with event handlers)
  - Add scroll support
  - Add hstack/vstack containers
  - Improve input (keyboard) handling
  - Implement copy/paste
  - Add HiDPI handling
  - Handle window resize
  - Improve handling of Color (turn to 0.0 to 1.0 instead of 0 to 255? only do it for alpha?)
  - Add handling of non visible widget nodes
  - Handle widget fixed size
  - Add good looking caret to textField
  - Add support for onFocus/onBlur
  - Maybe we don't need this and we can get by with position in render function?
    - Add support for onEnter/onLeave (keep track of previous active widgets)
    - We probably need it for drag&drop
  - How is the user going to provide state updates?
    - We already provide this with the State monad and corresponding lenses
  - Improve mouse support/current state of mouse and keyboard for event handling
  - Make handleEvent run inside MonadState (required to update user provided lenses) **CANCELLED**
  - Add logic that allows widgets to update user state
  - Does it make sense to avoid lenses internally, given that we already include the dependency?
  - How will long running (i.e., not immediate) user tasks will be handled?
  - Using local coordinates for widgets **CANCELLED**
    - How do we adjust current displacement?
  - Track drawing operations made by a Widget
    - Reorganize drawing operations
  - Stop, think and design
    - How should all of this be organized?
    - How should modules be laid out?
    - What are good interfaces for the different parts of the system?
    - Does it make sense that handleEvent is the only pure function in a widget?
    - Based on the previous design, refactor modules
  - Current massive refactor
    - Replace Tree with Containers' Tree
    - Fix issue with event handling (click makes everything disappear)
    - Fix focus situation (remove _focusRing and replace with single focus, then use widgetNextFocusable)
    - Provide focus to render (needed by textField)
    - Check if resize children still makes sense (maybe the widget itself can resize on the corresponding event?)
    - Handle SetFocus request
    - Check if WidgetState is really needed
        - Maybe Data.Dynamic can be used, but currently abandoned
    - Rethink Tree.Path import
    - Clean up Seq imports
    - Where can we use Seq? Does it make sense to use it everywhere? What about Traversable?
    - Reorganize Common Types. What do other projects do? They should be simple to import and use
  - Create composite widget, allowing isolated event handling and UI creation
  - Create application widget, based on composite
    - Remove UserTask concept, handle it as WidgetTask
  - Support long running tasks that can provide events through a channel
  - Add Multiple response support (extra value in EventResponse)
  - Try to remove all those Typeable requirements in CompositeWidget
    - Removing Monad from Widget/WidgetInstance was good enough
    - Some Typeable constraints still needed, but user should not need to do anything
  - Provide a way of initializing the application
    - Probably taking a simple event that is relayed to appEventsHandler is enough?
  - Implement Global keys
  - Improve merge process
  - Add a way to get path of widget given an id, and provide a method to send a message/event (most likely, a new Request kind)
  - Rename EventResult to something more accurate
    - Replace resultWidget and friends with non-Maybe versions (update widgets)
  - Add _renderLast_ function to Renderer, which delays rendering until the first pass is done
    - Futher calls to _renderLast_ should not be ignored (tooltip on dropdown menu?)
    - A _handleDelayedRendering_ also needs to be added
    - We also need a way of receiving events on _upper_ layers
    - All this is needed for dropdowns, but it's also useful for tooltips
  - Create Dropdown
  - Improve hstack/vstack
    - If available space is greater than requested, do not apply resizing logic
  - Does a styling engine make sense or doing something similar to Flutter is simpler?
    - Does keeping style for some things (fixed width/height) make sense?
      - Yes! All these properties are staying
    - Could container handle padding and centering?
      - No, staying how it is now. It does not disallow having a container, of course
    - Implement styling engine. Think why Maybe Double instead of Maybe Dimension (to handle pixels, percent, etc)
      - Handle this with a widget that takes care of assigning space
    - Improve FixedSize. Consider adding min/max width/height
      - Not for the moment
  - Improve ergonomics
    - https://hackage.haskell.org/package/string-interpolate
    - Check if advanced type level features would improve the design
    - Check what syntax extensions can be abused to make life easier
      - https://limperg.de/ghc-extensions/#basic-patterns
      - https://limperg.de/ghc-extensions/#datakinds
      - Maybe -> https://typeclasses.com/extensions-intro
    - Look for ways that allow both lenses and user events to be used in the same widget
      - Most likely through a Default instance
    - Related to previous, look for ways to simplify widget setup. Default instance with common values?
    - Find way of providing instance config (style, visibility, etc) before providing children (some sort of flip operator)
      - Just provide `style` after children. SwiftUI does it this way
    - Fix border drawing. Handle simple case (more efficient)
  - Fix scroll click navigation
    - Highlight bar when mouse over
    - Highlight handle when mouse over
    - Handle clicks in bar outside handle
    - Handle handle drag
    - Mouse over on overlapping axis gives precedence to vertical scroll
  - Keep sending mouse move event if mouse is away but button is still pressed
    - Handle mouse enter/leave window events
  - Add support for scroll requests from children
  - Improve Dropdown
    - Expose customizable interface
    - Request scroll when needed
    - Validate Maybe values are supported
    - Create nullable version which takes care of fmapping traversable with Just
  - Check why vstack fails when using [spacer, listView]
  - Remove status from Click event. Add ButtonPressed and ButtonReleased events
  - Change order of parameters. We should always pass _old_ before _new_
  - Unify criteria for instantiation
    - Component name without underscore receives parameters positionally
    - Component name with underscore receives Config instance
  - If two flexible sized and one remaining elements are in a vstack, problems arise
  - Add renderer parameter to resize. It will be needed for auto adjustable Label and to handle ellipsis in texts
    - Maybe creating a record of functions would be useful?
    - Besides calcTextBounds, we need isClipboardPaste and isClipboardCopy which could be customizable
      - Customization discarded. What would it be needed for?
  - Try to unify path handling on widgetFind and widgetNextFocusable
    - This is cancelled fo the moment. I can't find a good reason for doing it.
    - WidgetEnv was added as a parameter for completeness sake
    - This is also needed for widgetUpdateSizeReq and widgetResize
    - Generalize the "startFrom" concept of widgetFind (and also validate it's actually well/fully implemented)
  - Should Resize be restored? -> Restored
  - Make sure enabled/visible attributes are being used
    - This needs modifying WidgetContext (former PathContext) to include visible and enabled attributes
  - Move widgetPath into WidgetInstance (do it in init/merge)
    - Move currentPath into WidgetInstance
    - Move focusedPath and targetPath to WidgetEnv
    - Visible and enabled would get updated on init/merge
  - Format code!
  - Use newtypes whenever possible
  - Make types Lens friendly
    - Use lenses whenever they make the code clearer
    - Use Lenses for Main/Core.hs' updateInputStatus
    - Create Lenses for Graphics/Types.hs
  - Make BaseWidget and BaseContainer use a custom type instead of just Widget. Maybe also rename them?
  - Improve styling options. Handle cases for Normal, Hover, Focused with independent background and border
  - Add support for dashed borders
    - NanoVG does not seem to support this
    - If we ever move to Skia, reconsider
  - Fix ListView keyboard navigation
  - Handle mouse entering/leaving the window
  - Rename policy... to policyW/H
  - Create Checkbox
  - Create Radio
  - Reorganize Drawing (move helpers to bottom)
  - Create Image
  - Add config for Label to choose from: Overflow | Cut (better name?) | Ellipsis
  - DrawStyledBackground should draw borders after widget content
  - Request text input when text field gets focus (required for mobile)
    - Also set TextInputRect
  - Improve textField
    - Add text selection/editing to textField
    - Find non visible character that returns correct height if input is empty
  - Can we generalize widgetFind?
    - To find widgetInstances that need a specific kind of event (entities that need timeStep)
    - Instead of passing Point, pass WidgetQuery ADT. Currently it would support... PointQuery
    - Do we need this?
    - It is implemented in chore/unify-query. I honestly don't think it's an improvement
  - Further textField improvements
    - Handle long text and cursor position
      - Scissor needed?
    - Add support for changing cursor position with mouse click
  - Rethink Image handling
    - Should image component keep a copy around?
    - Should it be provided to renderer every time and, if removed, put back in the list?
    - Otherwise, when graphics memory is exhausted new images will not be added (until the widget is disposed)
  - Rethink the idea of global theme in WidgetEnv
    - Add option to render inner rounded borders with normal outer ones
  - Further textField improvements
    - Add support for validation
    - Add max length limit
    - Add range limit
    - Initialize validators (maybe input is invalid and that needs to be signaled)
  - Think widget config in a similar way to style config (combinator functions)
  - textField should support textFieldV and validInputV
    - Add mandatory event parameter for V constructors
  - Why does the model update when trying to input a char in FloatingInput?
  - Focus event not received after clicking and gaining focus
  - Rethink focus handling. Maybe return a list of all focusable elements? Currently shift-tab is not possible
    - Added a direction parameter to widgetFindNextFocus
  - Think about argument position for widgets, in particular listview/radio
    - Should value come before items/option?
    - Should we use a list of configs instead of <> operator?
  - Add options to label/button (ellipsis/cut)
  - Add support for urls to image widget
  - Add options to image widget (stretch/crop/etc)
    - Check if re-adding image on render should be inside lock
  - Improve spacer
  - Remove Tree
  - Check why image dissapears when model changes (missing merge)
  - Reorganize modules.
    -  Common and Widget merged into new Core?
    -  Widget.Widgets moved to Widget?
    -  WidgetCombinators and StyleCombinators merged into a single Combinators?
    -  Create Lens package. BasicTypes lenses should also be there
    -  Create separate Util/WidgetUtil (rename Types to WidgetTypes)
    -  Simplify imports
    -  Create Lens.hs in each module instead of directory
    -  Clean up checkbox/radio (fgcolor, etc)
  - Simplify Main.hs by abstracting SDL initialization
  - Add center, right components based on box
  - Validate font exists before using it in NanoVG (crashes otherwise)
    - Also added default font
  - Check if textBounds is enough, or we're missing descending part of font
    - getFullTextSize should be used?
  - Make label use fixed height by default
  - Do not draw non visible items in grid/stack (outside viewport)
    - Apply scissor
  - WidgetRequest for error messages? Probably not worth it
    - Maybe provide a config where a notification/lens can be sent?
  - Fix dropdown issues
    - Show listview in appropriate location (if dropdown is at the bottom, the listView should be up)
    - Implement OnChange/OnChangeReq for listView and dropdown (currently they only implement the Idx versions)
  - Fix issue on scroll. If moved and later expanded, content remains displaced
  - Fix text size/cursor position issue
  - Create Layer widget
  - Add clickOutsideChild in box
  - Create Dialog
    - Receive Title + Message
      - Receive Confirm and Cancel actions
      - Receive Actions and Labels
    - Receive title, body and buttons (actions and labels)
  - Check if there's a 1px error in click handling
    - Seems ok
  - Is overlay not being cleared up? Fixed
  - Review all uses of viewport
  - Add cursor handling
    - Most likely handled as part of style. Discard margins, but consider border + padding
    - Maybe also add an option like SetOverlay
  - Handle findNextFocus in zstack (only consider top layer, unless configured otherwise)
  - Keyboard not working on dropdown
  - Make sure that focus change requests do not leave overlay if active (most likely an if clause is needed in handleFocusChange)
  - Return list of actions instead of Monoid in eventHandler
  - Add way of requesting findNextFocus (needed on Dropdown)
  - Add way of ignoring unassigned events in stack (or return nothing from findByPoint)
  - Update style when merging to avoid recalculating/merging theme every time
  - Use theme for all components
  - Replace uses of Seq.zip with foldlWithIndex
  - Check provided renderArea is used correctly
  - Provided viewport should consider parent viewport
  - Check scroll styling works correctly (contentRect being applied, etc)
    - Also handle hover so scrollbars get correct cursor
  - Move computeTextRect out of Renderer
  - Multiline label
  - Check dropdown width/ellipsis
  - Button should receive focus
  - Move combinators out of exported Core (but still export from Monomer)
    - Cancelled, not sure if it's an improvement
  - Maybe unify criteria on zstack? Top layer config for both focus/click?
  - Check getState/merge in all components
  - Further textField improvements
    - Check displaced textField when adding characters on right align
      - Also, when right is reached from left, everything is pushed out of screen
    - Double clicking on empty puts the cursor at the end of ghost character
    - Right aligned version has cusor overlaid (add caret size to offset in specific cases)
    - Check clipboard
  - Check Container thing in hover adding columns (not targetValid = Nothing should be removed)
  - Add missing keyboard functions in Event
  - Handle onBlur/onFocus in all focusable widgets
  - Find way of avoiding hover effects when widget is not in the top layer
    - Hover should only be active for top level item
      - I need to think a way of setting a layer state for zstack
  - Maybe isPointInViewport should be replaced by something specific for each Widget
    - Generalized utility functions to use them in specific widgets
    - The findWidgetByPoint route is problematic, since it can lead to mutual recursion
  - TextStyle changes **CANCELLED**
    - TextOverflow in TextStyle?
    - Add Bold/Italic support (instead of different Font for each case)
  - Button should change color when clicked/actioned
  - Check label with flexHeight (multilabel was not showing first line if it did not fit)
  - Add Maps on Theme to handle user widget settings
  - Handle window title, maximize, etc
    - Also handle as requests?
    - Provide a way of exiting application/close window handler
  - Think about label size (fixed by default? lower factor)
  - Avoid excessive delay on window resize
  - Check 1px difference on right side of labels/buttons (probably already fixed)
  - VStack should set itself to a fixed size if all children are fixed
  - Remember use case for containerStyleOnMerge (scroll size, but can't replicate)
    - Using it makes everything painfully slow
    - Most likely related to focus of nested components. Maybe filtering move/hover out is enough?
    - Now fixed, but still need to test old use cases work fine
  - Default to integrated graphics
    - http://supermegaultragroovy.com/2016/12/10/auto-graphics-switching/
  - Can we avoid redrawing if no event happened?
    - Action events still cause rendering to happen (otherwise it's painful for widget developers)
    - Move events need to request rendering
  - Improve listView performance (avoid merge/resize)
    - Maybe some composites could have a typeclass for its constructor, and react differently if provided Eq?
    - Still need to provide method for custom mergeNeeded check
  - Avoid forced resize after merge (if an item needs more space, it should request it)
  - Avoid rebuilding glyphs if renderArea did not change for label
  - Fix dialog not generating RenderOnce
    - The issue was in zstack, where changing visible items should generate a resize request
  - Review composite initialization. View creation can be moved to init
    - Check if passing model directly is still correct
  - Test nested composites
  - Update signatures of methods to use Widget/WidgetInstance as needed (restrict what can be changed)
    - Change WidgetResult so WidgetInstance is Maybe
      - This allows having a Default instance and later use lenses instead of the resultX functions
    - Remove Maybe from handleEvent/handleMessage return type
    - Reverted. Reward was low, and getSizeReq/resize were still inconsistent
  - Can _wiChildren be removed from Widget and only be kept in Container?
    - Postponed/cancelled. After all the refactoring attempts regarding WidgetResult, I'm not sure about the benefits
  - Change interfaces
    - Several items were dropped or implemented and then reverted
      - Main reason was requiring explicit Typeable annotations on s and e, which leads to pain on the user's side
      - Code complexity also increased for a really small payoff (if any)
    - Change return type and the moment when widgetUpdateSizeReq is called
    - Comment GlobalKeys out and have Container use its local list of children for merging
    - Create WidgetNode type, move Widget/children into it
      - Remove type constraints on WidgetInstance
      - Change type signatures to use WidgetNode
    - Restore GlobalKeys
      - Add method to collect tree of WidgetInstances
      - Also return map of GlobalKeys
  - Do not hover if mouse drag on different widget
  - Fix selectOnBlur for dropdown
  - Rename WidgetInstance to WidgetNodeStatus (or similar)
  - Check dropdown's list not being properly located after resize/scroll (not clear)
  - Rename WidgetResult's widget to node
  - Remove createThemed and move Alert/Dialog to use composite

- Pending
  - Add testing
    - Delayed until this point to try to settle down interfaces
    - Validate stack assigns space correctly
    - Use weight to control allocations
    - Refactor modules where consistency is lacking
  - Add header in all files, indicating license and documenting what the module does
    - Add license for used fonts, etc
  - Add examples
    - Basic event handling (maybe a form with input and button?)
    - Fetch content from url, show rows of data with embedded images
    - Composite example
    - Something of generative art (OpenGL example)
  - Add user documentation

Maybe postponed after release?
  - Restore container changes for controlling merge of children (part of reverted scroll changes)
  - Draw close button on Dialog
  - Check why putting box reduces label's space
    - scroll $ vstack $ (\i -> box $ label ("Label: " <> showt i)) <$> [0..100::Int]
  - Set focus on ButtonDown, not Click
    - Can it be handled in Single/Container?
  - Restore focus to previous widget when zstack changes (dialog situation)
    - Also think about not losing focus because of click (when onlyTopFocusable is active)
  - ZStack should set _weIsTopLayer based on used space
  - Image
    - Can performance be improved? Use sbt functions?
    - Does adding function to return imgData from Renderer make sense? Replace imageExists?
    - Remove delay logic when adding an image
    - When adding image, on failure remove an the least used image and retry
  - Make sure WidgetTask/Node association is preserved if node location in tree changes
  - Further textField improvements
    - Handle undo history
    - Handle mouse selection
    - Create numeric wrapper that allows increasing/decreasing with mouse
  - Scroll wheel rate should be configurable, or even depend on content size
  - Check if SDL can be initialized headless (for tests that involve the API)
    - https://discourse.libsdl.org/t/possible-to-run-sdl2-headless/25665/2
  - Does it make sense to handle offset
    - It would avoid resizing on scroll
    - We need transform stack on Renderer (also rotate?)
    - We need to transform events
      - This way we avoid having to translate widgets
    - We need current transform in WidgetEnv
      - Only used for rendering
      - hovered would also use it
    - We need to set transform on render (and clear it)
    - Check scroll in scroll (one with max height)
  - Remove getSizeReq from Widget interface. Keep it in Single/Container
    - Other Widgets should take care of updating those fields during init/merge/handleEvent/handleMessage
  - Create Keystroke component (shortcuts and general key handling like Esc for dialog)
  - Create Tooltip component. It just wraps a given component and draws the tooltip with renderOverlay
  - Create Theme widget to override global theme
  - Create Slider
  - Create Dial
  - Create Split
  - Create Layout with width/heights specified in percents
  - Create File Selector
  - Create Color Selector
  - Create self rendered version of dropdown and list
  - Drag & drop for user (add attribute indicating if component supports being source/target)
    - Add new request types (drag started, drag stopped, drag cancelled)
    - Add new events (drag hover)
    - SDL supports Drag and Drop integration with OS
  - Compare Cairo/Skia/ImDrawList interfaces to make Renderer able to handle future implementations
    - https://github.com/ollix/MetalNanoVG
  - Improve window resize situation
    - SDL does not send resize until operation has finished, making content look ugly because it's not updated
    - Check SDL_SetEventFilter trick instead of normal polling (https://wiki.libsdl.org/SDL_SetEventFilter)
  - Check if using [lifted-async](https://github.com/maoe/lifted-async) is worth it
  - Look for alternatives to NanoVG
    - Check ImDrawList. Support for OpenGL/Metal/Vulkan out of the box
    - Check SDL_Surface + Cairo backend. It most likely won't happen
  - Add new request types (drag started, drag stopped, drag cancelled)
  - Add new events (drag hover)
  - SDL supports Drag and Drop integration with OS
