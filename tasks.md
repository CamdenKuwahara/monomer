- Done
  - Check events only for interested widgets (use focus for keyboard and region for mouse)
  - Add handling of disabled widget nodes
  - Add handling of custom external actions for widgets
  - Do something with return of custom handlers (the exact same thing we do with event handlers)
  - Add scroll support
  - Add hstack/vstack containers
  - Improve input (keyboard) handling
  - Implement copy/paste
  - Add HiDPI handling
  - Handle window resize
  - Improve handling of Color (turn to 0.0 to 1.0 instead of 0 to 255? only do it for alpha?)
  - Add handling of non visible widget nodes
  - Handle widget fixed size
  - Add good looking caret to textField
  - Add support for onFocus/onBlur
  - Maybe we don't need this and we can get by with position in render function?
    - Add support for onEnter/onLeave (keep track of previous active widgets)
    - We probably need it for drag&drop
  - How is the user going to provide state updates?
    - We already provide this with the State monad and corresponding lenses
  - Improve mouse support/current state of mouse and keyboard for event handling
  - Make handleEvent run inside MonadState (required to update user provided lenses) **CANCELLED**
  - Add logic that allows widgets to update user state
  - Does it make sense to avoid lenses internally, given that we already include the dependency?
  - How will long running (i.e., not immediate) user tasks will be handled?
  - Using local coordinates for widgets **CANCELLED**
    - How do we adjust current displacement?
- Pending
  - Can we keep track of who makes a given draw call?
    - Can we cache some drawing operations?
    - Think about possible caching and usage of SDL_Surface + Cairo
  - Stop, think and design
    - How should all of this be organized?
    - How should modules be layed out?
    - What are good interfaces the different parts of the system?
    - Does it make sense that handleEvent is the only pure function in a widget?
    - Based on the previous design, refactor modules
  - Improve hstack/vstack
    - If space is available space is greater than requested, do not apply resizing logic
  - Does a styling engine make sense or doing something similar to Flutter is simpler?
    - Could container handle padding and centering?
    - Implement styling engine. Think why Maybe Double instead of Maybe Dimension (to handle pixels, percent, etc)
  - Improve ergonomics
    - Check if advanced type level features would improve the design
    - Check what syntax extensions can be abused to make life easier
    - Look for ways that allow both lenses and user events to be used in the same widget
    - Related to previous, look for ways to simplify widget setup. Default instance with common values?
  - Keep sending mouse move event if mouse is away but button is still pressed
  - Create layer widget to handle overlays/dialog boxes/tooltips (takes care of overlays)
  - Add text selection/editing to textField
  - Create Checkbox
  - Create Radio
  - Create Dropdown
  - Create Color Selector
  - Create Dialog
  - Create File Selector
  - Drag & drop for user (add attribute indicating if component supports being source/target)
    - Add new request types (drag started, drag stopped, drag cancelled)
    - Add new events (drag hover)
