- Done
  - Check events only for interested widgets (use focus for keyboard and region for mouse)
  - Add handling of disabled widget nodes
  - Add handling of custom external actions for widgets
  - Do something with return of custom handlers (the exact same thing we do with event handlers)
  - Add scroll support
  - Add hstack/vstack containers
  - Improve input (keyboard) handling
  - Implement copy/paste
  - Add HiDPI handling
  - Handle window resize
  - Improve handling of Color (turn to 0.0 to 1.0 instead of 0 to 255? only do it for alpha?)
  - Add handling of non visible widget nodes
  - Handle widget fixed size
  - Add good looking caret to textField
  - Add support for onFocus/onBlur
  - Maybe we don't need this and we can get by with position in render function?
    - Add support for onEnter/onLeave (keep track of previous active widgets)
    - We probably need it for drag&drop
  - How is the user going to provide state updates?
    - We already provide this with the State monad and corresponding lenses
  - Improve mouse support/current state of mouse and keyboard for event handling
  - Make handleEvent run inside MonadState (required to update user provided lenses) **CANCELLED**
  - Add logic that allows widgets to update user state
  - Does it make sense to avoid lenses internally, given that we already include the dependency?
  - How will long running (i.e., not immediate) user tasks will be handled?
  - Using local coordinates for widgets **CANCELLED**
    - How do we adjust current displacement?
  - Track drawing operations made by a Widget
    - Reorganize drawing operations
  - Stop, think and design
    - How should all of this be organized?
    - How should modules be layed out?
    - What are good interfaces for the different parts of the system?
    - Does it make sense that handleEvent is the only pure function in a widget?
    - Based on the previous design, refactor modules
  - Current massive refactor
    - Replace Tree with Containers' Tree
    - Fix issue with event handling (click makes everything disappear)
    - Fix focus situation (remove _focusRing and replace with single focus, then use _widgetNextFocusable)
    - Provide focus to render (needed by textField)
    - Check if resize children still makes sense (maybe the widget itself can resize on the corresponding event?)
    - Handle SetFocus request
    - Check if WidgetState is really needed
        - Maybe Data.Dynamic can be used, but currently abadoned
    - Rethink Tree.Path import
    - Clean up Seq imports
    - Where can we use Seq? Does it make sense to use it everywhere? What about Traversable?
    - Reorganize Common Types. What do other projects do? They should be simple to import and use
  - Create composite widget, allowing isolated event handling and UI creation
  - Create application widget, based on composite
    - Remove UserTask concept, handle it as WidgetTask
  - Support long running tasks that can provide events through a channel

- Pending
  - Add Multiple response support (extra value in EventResponse)
  - Add a way to get path of widget given an id, and provide a method to send a message/event
  - Provide a way of initializing the application
    - Probably taking a simple event that is relayed to appEventsHandler is enough?
  - Can we generalize _widgetFind?
    - To find widgetInstances that need a specific kind of event (entities that need timeStep)
  - Improve merge process. Implement Global keys
  - Add _renderLast_ function to Renderer, which delays rendering until the first pass is done
    - Futher calls to _renderLast_ should not be ignored (tooltip on dropdown menu?)
    - A _handleDelayedRendering_ also needs to be added
    - We also need a way of receiving events on _upper_ layers
    - This all is needed for dropdowns, but it's also useful for tooltips
  - Improve hstack/vstack
    - If available space is greater than requested, do not apply resizing logic
  - Does a styling engine make sense or doing something similar to Flutter is simpler?
    - Does keeping style for some things (fixed width/height) make sense?
    - Could container handle padding and centering?
    - Implement styling engine. Think why Maybe Double instead of Maybe Dimension (to handle pixels, percent, etc)
    - Improve FixedSize. Consider adding min/max width/height
  - Improve ergonomics
    - https://hackage.haskell.org/package/string-interpolate
    - Check if advanced type level features would improve the design
    - Check what syntax extensions can be abused to make life easier
      - https://limperg.de/ghc-extensions/#basic-patterns
      - https://limperg.de/ghc-extensions/#datakinds
      - Maybe -> https://typeclasses.com/extensions-intro
    - Look for ways that allow both lenses and user events to be used in the same widget
      - Most likely through a Default instance
    - Related to previous, look for ways to simplify widget setup. Default instance with common values?
    - Find way of providing instance config (style, visibility, etc) before providing children (some sort of flip operator)
  - Keep sending mouse move event if mouse is away but button is still pressed
  - Fix scroll click navigation
  - Create layer widget to handle overlays/dialog boxes/tooltips (takes care of overlays)
  - Add text selection/editing to textField
  - Add testing
    - Delayed until this point to try to settle down interfaces
  - Create Checkbox
  - Create Radio
  - Create Dropdown
  - Create Color Selector
  - Create Dialog
  - Create File Selector
  - Drag & drop for user (add attribute indicating if component supports being source/target)
    - Add new request types (drag started, drag stopped, drag cancelled)
    - Add new events (drag hover)
    - SDL supports Drag and Drop integration with OS
  - Implement SDL_Surface + Cairo backend
    - Can we cache some drawing operations?
  - Check if using [lifted-async](https://github.com/maoe/lifted-async) is worth it
  - Try to remove all those Typeable requirements in CompositeWidget
    - Maybe passing the current root as a parameter?
    - Find a way of providing a function that creates the updated UI, and avoid storing it in state?
    - Just use a field in WidgetInstance?
    - It does not seem possible with current design
      - What about adding ep and sp to Widget/WidgetInstance?
      - Create PWidget/PWidgetInstance
